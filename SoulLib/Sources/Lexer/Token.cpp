#include "Lexer/Token.h"

#include <unordered_map>

namespace Soul::Lexer
{
	Bool8 Token::Equals(const Token lhs, const Token rhs) noexcept { return lhs.type == rhs.type; }

	StringView Token::Name(const TokenType type) noexcept
	{
		static const std::unordered_map<TokenType, StringView> k_token_name = {
			{ TokenType::TOKEN_KEYWORD_BREAK,              "break"_sv          },
			{ TokenType::TOKEN_KEYWORD_CAST,               "cast"_sv           },
			{ TokenType::TOKEN_KEYWORD_CONTINUE,           "continue"_sv       },
			{ TokenType::TOKEN_KEYWORD_ELSE,               "else"_sv           },
			{ TokenType::TOKEN_KEYWORD_FALSE,              "false"_sv          },
			{ TokenType::TOKEN_KEYWORD_FN,                 "fn"_sv             },
			{ TokenType::TOKEN_KEYWORD_FOR,                "for"_sv            },
			{ TokenType::TOKEN_KEYWORD_IF,                 "if"_sv             },
			{ TokenType::TOKEN_KEYWORD_LET,                "let"_sv            },
			{ TokenType::TOKEN_KEYWORD_MUT,                "mut"_sv            },
			{ TokenType::TOKEN_KEYWORD_NATIVE,             "native"_sv         },
			{ TokenType::TOKEN_KEYWORD_NULL,               "null"_sv           },
			{ TokenType::TOKEN_KEYWORD_RETURN,             "return"_sv         },
			{ TokenType::TOKEN_KEYWORD_STRUCT,             "struct"_sv         },
			{ TokenType::TOKEN_KEYWORD_TRUE,               "true"_sv           },
			{ TokenType::TOKEN_KEYWORD_WHILE,              "while"_sv          },
			{ TokenType::TOKEN_LITERAL_FLOAT,              "float literal"_sv  },
			{ TokenType::TOKEN_LITERAL_IDENTIFIER,         "identifier"_sv     },
			{ TokenType::TOKEN_LITERAL_INTEGER,            "int literal"_sv    },
			{ TokenType::TOKEN_LITERAL_STRING,             "string literal"_sv },
			{ TokenType::TOKEN_SYMBOL_AMPERSAND,           "&"_sv              },
			{ TokenType::TOKEN_SYMBOL_AMPERSAND_AMPERSAND, "&&"_sv             },
			{ TokenType::TOKEN_SYMBOL_CARET,               "^"_sv              },
			{ TokenType::TOKEN_SYMBOL_COMMA,               ","_sv              },
			{ TokenType::TOKEN_SYMBOL_DOT,                 "."_sv              },
			{ TokenType::TOKEN_SYMBOL_GREATER,             ">"_sv              },
			{ TokenType::TOKEN_SYMBOL_GREATER_EQUAL,       ">="_sv             },
			{ TokenType::TOKEN_SYMBOL_LESS,                "<"_sv              },
			{ TokenType::TOKEN_SYMBOL_LESS_EQUAL,          "<="_sv             },
			{ TokenType::TOKEN_SYMBOL_MINUS,               "-"_sv              },
			{ TokenType::TOKEN_SYMBOL_MINUS_EQUAL,         "-="_sv             },
			{ TokenType::TOKEN_SYMBOL_MINUS_MINUS,         "--"_sv             },
			{ TokenType::TOKEN_SYMBOL_PERCENT,             "%"_sv              },
			{ TokenType::TOKEN_SYMBOL_PERCENT_EQUAL,       "%="_sv             },
			{ TokenType::TOKEN_SYMBOL_PIPE,                "|"_sv              },
			{ TokenType::TOKEN_SYMBOL_PIPE_PIPE,           "||"_sv             },
			{ TokenType::TOKEN_SYMBOL_PLUS,                "+"_sv              },
			{ TokenType::TOKEN_SYMBOL_PLUS_EQUAL,          "+="_sv             },
			{ TokenType::TOKEN_SYMBOL_PLUS_PLUS,           "++"_sv             },
			{ TokenType::TOKEN_SYMBOL_QUESTION_MARK,       "?"_sv              },
			{ TokenType::TOKEN_SYMBOL_SLASH,               "/"_sv              },
			{ TokenType::TOKEN_SYMBOL_SLASH_EQUAL,         "/="_sv             },
			{ TokenType::TOKEN_SYMBOL_STAR,                "*"_sv              },
			{ TokenType::TOKEN_SYMBOL_STAR_EQUAL,          "*="_sv             },
			{ TokenType::TOKEN_SYMBOL_BANG,                "!"_sv              },
			{ TokenType::TOKEN_SYMBOL_BANG_EQUAL,          "!="_sv             },
			{ TokenType::TOKEN_SYMBOL_BRACE_LEFT,          "{"_sv              },
			{ TokenType::TOKEN_SYMBOL_BRACE_RIGHT,         "}"_sv              },
			{ TokenType::TOKEN_SYMBOL_BRACKET_LEFT,        "["_sv              },
			{ TokenType::TOKEN_SYMBOL_BRACKET_RIGHT,       "]"_sv              },
			{ TokenType::TOKEN_SYMBOL_COLON,               ":"_sv              },
			{ TokenType::TOKEN_SYMBOL_COLON_COLON,         "::"_sv             },
			{ TokenType::TOKEN_SYMBOL_EQUAL,               "="_sv              },
			{ TokenType::TOKEN_SYMBOL_EQUAL_EQUAL,         "=="_sv             },
			{ TokenType::TOKEN_SYMBOL_PAREN_LEFT,          "("_sv              },
			{ TokenType::TOKEN_SYMBOL_PAREN_RIGHT,         ")"_sv              },
			{ TokenType::TOKEN_SYMBOL_SEMICOLON,           ";"_sv              },
			{ TokenType::TOKEN_SPECIAL_ERROR,              "__ERROR__"_sv      },
			{ TokenType::TOKEN_SPECIAL_END_OF_FILE,        "__EOF__"_sv        },
		};
		return k_token_name.at(type);
	}

	StringView Token::NameInternal(TokenType type) noexcept
	{
		static const std::unordered_map<TokenType, StringView> k_token_name = {
			{ TokenType::TOKEN_KEYWORD_BREAK,              "keyword_break"_sv              },
			{ TokenType::TOKEN_KEYWORD_CAST,               "keyword_cast"_sv               },
			{ TokenType::TOKEN_KEYWORD_CONTINUE,           "keyword_continue"_sv           },
			{ TokenType::TOKEN_KEYWORD_ELSE,               "keyword_else"_sv               },
			{ TokenType::TOKEN_KEYWORD_FALSE,              "keyword_false"_sv              },
			{ TokenType::TOKEN_KEYWORD_FN,                 "keyword_fn"_sv                 },
			{ TokenType::TOKEN_KEYWORD_FOR,                "keyword_for"_sv                },
			{ TokenType::TOKEN_KEYWORD_IF,                 "keyword_if"_sv                 },
			{ TokenType::TOKEN_KEYWORD_LET,                "keyword_let"_sv                },
			{ TokenType::TOKEN_KEYWORD_MUT,                "keyword_mut"_sv                },
			{ TokenType::TOKEN_KEYWORD_NATIVE,             "keyword_native"_sv             },
			{ TokenType::TOKEN_KEYWORD_NULL,               "keyword_null"_sv               },
			{ TokenType::TOKEN_KEYWORD_RETURN,             "keyword_return"_sv             },
			{ TokenType::TOKEN_KEYWORD_STRUCT,             "keyword_struct"_sv             },
			{ TokenType::TOKEN_KEYWORD_TRUE,               "keyword_true"_sv               },
			{ TokenType::TOKEN_KEYWORD_WHILE,              "keyword_while"_sv              },
			{ TokenType::TOKEN_LITERAL_FLOAT,              "literal_float"_sv              },
			{ TokenType::TOKEN_LITERAL_IDENTIFIER,         "literal_identifier"_sv         },
			{ TokenType::TOKEN_LITERAL_INTEGER,            "literal_integer"_sv            },
			{ TokenType::TOKEN_LITERAL_STRING,             "literal_string"_sv             },
			{ TokenType::TOKEN_SYMBOL_AMPERSAND,           "symbol_ampersand"_sv           },
			{ TokenType::TOKEN_SYMBOL_AMPERSAND_AMPERSAND, "symbol_ampersand_ampersand"_sv },
			{ TokenType::TOKEN_SYMBOL_CARET,               "symbol_caret"_sv               },
			{ TokenType::TOKEN_SYMBOL_COMMA,               "symbol_comma"_sv               },
			{ TokenType::TOKEN_SYMBOL_DOT,                 "symbol_dot"_sv                 },
			{ TokenType::TOKEN_SYMBOL_GREATER,             "symbol_greater"_sv             },
			{ TokenType::TOKEN_SYMBOL_GREATER_EQUAL,       "symbol_greater_equal"_sv       },
			{ TokenType::TOKEN_SYMBOL_LESS,                "symbol_less"_sv                },
			{ TokenType::TOKEN_SYMBOL_LESS_EQUAL,          "symbol_less_equal"_sv          },
			{ TokenType::TOKEN_SYMBOL_MINUS,               "symbol_minus"_sv               },
			{ TokenType::TOKEN_SYMBOL_MINUS_EQUAL,         "symbol_minus_equal"_sv         },
			{ TokenType::TOKEN_SYMBOL_MINUS_MINUS,         "symbol_minus_minus"_sv         },
			{ TokenType::TOKEN_SYMBOL_PERCENT,             "symbol_percent"_sv             },
			{ TokenType::TOKEN_SYMBOL_PERCENT,             "symbol_percent_equal"_sv       },
			{ TokenType::TOKEN_SYMBOL_PIPE,                "symbol_pipe"_sv                },
			{ TokenType::TOKEN_SYMBOL_PIPE_PIPE,           "symbol_pipe_pipe"_sv           },
			{ TokenType::TOKEN_SYMBOL_PLUS,                "symbol_plus"_sv                },
			{ TokenType::TOKEN_SYMBOL_PLUS_EQUAL,          "symbol_plus_equal"_sv          },
			{ TokenType::TOKEN_SYMBOL_PLUS_PLUS,           "symbol_plus_plus"_sv           },
			{ TokenType::TOKEN_SYMBOL_QUESTION_MARK,       "symbol_question_mark"_sv       },
			{ TokenType::TOKEN_SYMBOL_SLASH,               "symbol_slash"_sv               },
			{ TokenType::TOKEN_SYMBOL_SLASH_EQUAL,         "symbol_slash_equal"_sv         },
			{ TokenType::TOKEN_SYMBOL_STAR,                "symbol_star"_sv                },
			{ TokenType::TOKEN_SYMBOL_STAR_EQUAL,          "symbol_star_equal"_sv          },
			{ TokenType::TOKEN_SYMBOL_BANG,                "symbol_bang"_sv                },
			{ TokenType::TOKEN_SYMBOL_BANG_EQUAL,          "symbol_bang_equal"_sv          },
			{ TokenType::TOKEN_SYMBOL_BRACE_LEFT,          "symbol_brace_left"_sv          },
			{ TokenType::TOKEN_SYMBOL_BRACE_RIGHT,         "symbol_brace_right"_sv         },
			{ TokenType::TOKEN_SYMBOL_BRACKET_LEFT,        "symbol_bracket_left"_sv        },
			{ TokenType::TOKEN_SYMBOL_BRACKET_RIGHT,       "symbol_bracket_right"_sv       },
			{ TokenType::TOKEN_SYMBOL_COLON,               "symbol_colon"_sv               },
			{ TokenType::TOKEN_SYMBOL_COLON_COLON,         "symbol_colon_colon"_sv         },
			{ TokenType::TOKEN_SYMBOL_EQUAL,               "symbol_equal"_sv               },
			{ TokenType::TOKEN_SYMBOL_EQUAL_EQUAL,         "symbol_equal_equal"_sv         },
			{ TokenType::TOKEN_SYMBOL_PAREN_LEFT,          "symbol_paren_left"_sv          },
			{ TokenType::TOKEN_SYMBOL_PAREN_RIGHT,         "symbol_paren_right"_sv         },
			{ TokenType::TOKEN_SYMBOL_SEMICOLON,           "symbol_semicolon"_sv           },
			{ TokenType::TOKEN_SPECIAL_ERROR,              "special_error"_sv              },
			{ TokenType::TOKEN_SPECIAL_END_OF_FILE,        "special_eof"_sv                },
		};
		return k_token_name.at(type);
	}
}  // namespace Soul::Lexer
