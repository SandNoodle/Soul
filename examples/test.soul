let mut c : int = 5;
if(true)
{
	c = 0;
}
else
{
	c = 6;
}

# ======================================================
# Defines
# ======================================================

# define MY_ALIAS 1337;

# ======================================================
# Variables
# ======================================================

# let num_variable : u64 = 540133769;
# let bool_true_variable : b8 = true;
# let bool_false_variable : b8 = false;
# let str_variable : str = "Hello, Soul!";
# let chr_variable : chr = "C";

# # Mutable
# let mut mutable_variable : u64 = 500;

# @TODO Arrays
# let test_array : [i32] = { 0, 1, 2, 3, 4, 5 };

# Declaration Assign
# let my_var : u32 = 1337;
# let first_assigned_var : u32 = my_var;
# let second_assigned_var : u32 = first_assigned_var;

# Declared Assign
# second_assigned_var = my_var;

# second_assigned_var = test_func; # COMPILE_ERROR: Cannot assign function to a variable of type u32.

# ======================================================
# Binary operators
# ======================================================

# let var_a : u32 = 123;
# let var_b : u32 = 321;

# VAR_IDENT LEFT AND RIGHT
# let add_res : u32 = var_a + var_b;
# let sub_res : u32 = var_a - var_b;
# let mul_res : u32 = var_a * var_b;
# let div_res : u32 = var_a / var_b;

# LITERALS
# let add_lit_res : u32 = 120 + 540;
# let sub_lit_res : u32 = 120 - 540;
# let mul_lit_res : u32 = 120 * 540;
# let div_lit_res : u32 = 120 / 540;

# MIXED
# let add_mix_res : u32 = var_a + 54;
# let sub_mix_res : u32 = var_a - 54;
# let mul_mix_res : u32 = var_a * 54;
# let div_mix_res : u32 = var_a / 54;

# WRONG!
# let wrong_res_order : u32 = + 120 420;
# let wrong_res_missing_op_token : u32 = 120 420;
# let wrong_res_missing_lit_token : u32 = 120 +;

# ======================================================
# Functions
# ======================================================

# fn function_with_block :: void { let test_variable : i32 = 420; }
# fn function_without_params_short :: void { }
# fn function_without_params_long() :: void { }
# fn function_with_params (x: i32, y: i32) :: void { }
# fn function_with_void_type (x: i32, y: i32) :: void { }
# fn function_with_numeric_type (x: i32, y: i32) :: i32 { }
# fn function_with_numeric_return :: i32 { return 69; }
# fn function_with_numeric_param_return(x: i32, y: i32) :: i32 { return x + y; }

# ======================================================
# Control flow
# ======================================================

# if (true)
# {
# 	let true_variable : i32 = 420;
# }
# else
# {
# 	let false_variable : i32 = 540;
# }

# ======================================================
# Loops
# ======================================================

# while { }
# while (false) { }
# while { let while_var : i32 = 0; }
# while (false) { let while_var : i32 = 0; }


# for(;;) { }
# for(let mut index: i32 = 0; index < 10; index++) { }

# ======================================================
# Playground
# ======================================================

## TEST
# define MY_ALIAS 5;
# fn this_is_a_function :: void
# {
# 	while {
# 		let test_variable : str = "Hello, Soul!";
# 	}
#
# 	if(true) { let second : u64 = 5747; }
# }

## TEST: Number literal is greate than specified type (u8).
# EXPTECTED: [COMPILE_WARN] Value of a number literal is greater than specified type (u8). Capping value at: TYPE_MAX.
# let my_var : u8 = 1000000;

# =============================================================================
# Playground: PRECEDENCE PARSING
# =============================================================================

# This...
# let test_precedence : u32 = 1 + 2 * 3;

# should produce this...
#  ADD
#  / \
# 1  MUL
#    / \
#   2   3

# This...
# let test_precedence_2 : u32 = -var_b + 2 * 3;

# should produce this...
#       ADD
#     /     \
#   UNR     MUL
#   /  \    / \
# var_b -  2   3
