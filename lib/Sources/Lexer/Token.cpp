#include "Lexer/Token.h"

#include <unordered_map>

namespace Soul::Lexer
{
	using namespace std::string_view_literals;

	bool Token::Equal(const Token lhs, const Token rhs) noexcept { return lhs.type == rhs.type; }

	std::string_view Token::Name(const TokenType type) noexcept
	{
		static const std::unordered_map<TokenType, std::string_view> k_token_name = {
			{ TokenType::TOKEN_KEYWORD_BREAK,              "break"sv          },
			{ TokenType::TOKEN_KEYWORD_CAST,               "cast"sv           },
			{ TokenType::TOKEN_KEYWORD_CONTINUE,           "continue"sv       },
			{ TokenType::TOKEN_KEYWORD_ELSE,               "else"sv           },
			{ TokenType::TOKEN_KEYWORD_FALSE,              "false"sv          },
			{ TokenType::TOKEN_KEYWORD_FN,                 "fn"sv             },
			{ TokenType::TOKEN_KEYWORD_FOR,                "for"sv            },
			{ TokenType::TOKEN_KEYWORD_IF,                 "if"sv             },
			{ TokenType::TOKEN_KEYWORD_LET,                "let"sv            },
			{ TokenType::TOKEN_KEYWORD_MUT,                "mut"sv            },
			{ TokenType::TOKEN_KEYWORD_NATIVE,             "native"sv         },
			{ TokenType::TOKEN_KEYWORD_NULL,               "null"sv           },
			{ TokenType::TOKEN_KEYWORD_RETURN,             "return"sv         },
			{ TokenType::TOKEN_KEYWORD_STRUCT,             "struct"sv         },
			{ TokenType::TOKEN_KEYWORD_TRUE,               "true"sv           },
			{ TokenType::TOKEN_KEYWORD_WHILE,              "while"sv          },
			{ TokenType::TOKEN_LITERAL_FLOAT,              "float literal"sv  },
			{ TokenType::TOKEN_LITERAL_IDENTIFIER,         "identifier"sv     },
			{ TokenType::TOKEN_LITERAL_INTEGER,            "int literal"sv    },
			{ TokenType::TOKEN_LITERAL_STRING,             "string literal"sv },
			{ TokenType::TOKEN_SYMBOL_AMPERSAND,           "&"sv              },
			{ TokenType::TOKEN_SYMBOL_AMPERSAND_AMPERSAND, "&&"sv             },
			{ TokenType::TOKEN_SYMBOL_CARET,               "^"sv              },
			{ TokenType::TOKEN_SYMBOL_COMMA,               ","sv              },
			{ TokenType::TOKEN_SYMBOL_DOT,                 "."sv              },
			{ TokenType::TOKEN_SYMBOL_GREATER,             ">"sv              },
			{ TokenType::TOKEN_SYMBOL_GREATER_EQUAL,       ">="sv             },
			{ TokenType::TOKEN_SYMBOL_LESS,                "<"sv              },
			{ TokenType::TOKEN_SYMBOL_LESS_EQUAL,          "<="sv             },
			{ TokenType::TOKEN_SYMBOL_MINUS,               "-"sv              },
			{ TokenType::TOKEN_SYMBOL_MINUS_EQUAL,         "-="sv             },
			{ TokenType::TOKEN_SYMBOL_MINUS_MINUS,         "--"sv             },
			{ TokenType::TOKEN_SYMBOL_PERCENT,             "%"sv              },
			{ TokenType::TOKEN_SYMBOL_PERCENT_EQUAL,       "%="sv             },
			{ TokenType::TOKEN_SYMBOL_PIPE,                "|"sv              },
			{ TokenType::TOKEN_SYMBOL_PIPE_PIPE,           "||"sv             },
			{ TokenType::TOKEN_SYMBOL_PLUS,                "+"sv              },
			{ TokenType::TOKEN_SYMBOL_PLUS_EQUAL,          "+="sv             },
			{ TokenType::TOKEN_SYMBOL_PLUS_PLUS,           "++"sv             },
			{ TokenType::TOKEN_SYMBOL_QUESTION_MARK,       "?"sv              },
			{ TokenType::TOKEN_SYMBOL_SLASH,               "/"sv              },
			{ TokenType::TOKEN_SYMBOL_SLASH_EQUAL,         "/="sv             },
			{ TokenType::TOKEN_SYMBOL_STAR,                "*"sv              },
			{ TokenType::TOKEN_SYMBOL_STAR_EQUAL,          "*="sv             },
			{ TokenType::TOKEN_SYMBOL_BANG,                "!"sv              },
			{ TokenType::TOKEN_SYMBOL_BANG_EQUAL,          "!="sv             },
			{ TokenType::TOKEN_SYMBOL_BRACE_LEFT,          "{"sv              },
			{ TokenType::TOKEN_SYMBOL_BRACE_RIGHT,         "}"sv              },
			{ TokenType::TOKEN_SYMBOL_BRACKET_LEFT,        "["sv              },
			{ TokenType::TOKEN_SYMBOL_BRACKET_RIGHT,       "]"sv              },
			{ TokenType::TOKEN_SYMBOL_COLON,               ":"sv              },
			{ TokenType::TOKEN_SYMBOL_COLON_COLON,         "::"sv             },
			{ TokenType::TOKEN_SYMBOL_EQUAL,               "="sv              },
			{ TokenType::TOKEN_SYMBOL_EQUAL_EQUAL,         "=="sv             },
			{ TokenType::TOKEN_SYMBOL_PAREN_LEFT,          "("sv              },
			{ TokenType::TOKEN_SYMBOL_PAREN_RIGHT,         ")"sv              },
			{ TokenType::TOKEN_SYMBOL_SEMICOLON,           ";"sv              },
			{ TokenType::TOKEN_SPECIAL_ERROR,              "__ERROR__"sv      },
			{ TokenType::TOKEN_SPECIAL_END_OF_FILE,        "__EOF__"sv        },
		};
		return k_token_name.at(type);
	}

	std::string_view Token::NameInternal(TokenType type) noexcept
	{
		static const std::unordered_map<TokenType, std::string_view> k_token_name = {
			{ TokenType::TOKEN_KEYWORD_BREAK,              "keyword_break"sv              },
			{ TokenType::TOKEN_KEYWORD_CAST,               "keyword_cast"sv               },
			{ TokenType::TOKEN_KEYWORD_CONTINUE,           "keyword_continue"sv           },
			{ TokenType::TOKEN_KEYWORD_ELSE,               "keyword_else"sv               },
			{ TokenType::TOKEN_KEYWORD_FALSE,              "keyword_false"sv              },
			{ TokenType::TOKEN_KEYWORD_FN,                 "keyword_fn"sv                 },
			{ TokenType::TOKEN_KEYWORD_FOR,                "keyword_for"sv                },
			{ TokenType::TOKEN_KEYWORD_IF,                 "keyword_if"sv                 },
			{ TokenType::TOKEN_KEYWORD_LET,                "keyword_let"sv                },
			{ TokenType::TOKEN_KEYWORD_MUT,                "keyword_mut"sv                },
			{ TokenType::TOKEN_KEYWORD_NATIVE,             "keyword_native"sv             },
			{ TokenType::TOKEN_KEYWORD_NULL,               "keyword_null"sv               },
			{ TokenType::TOKEN_KEYWORD_RETURN,             "keyword_return"sv             },
			{ TokenType::TOKEN_KEYWORD_STRUCT,             "keyword_struct"sv             },
			{ TokenType::TOKEN_KEYWORD_TRUE,               "keyword_true"sv               },
			{ TokenType::TOKEN_KEYWORD_WHILE,              "keyword_while"sv              },
			{ TokenType::TOKEN_LITERAL_FLOAT,              "literal_float"sv              },
			{ TokenType::TOKEN_LITERAL_IDENTIFIER,         "literal_identifier"sv         },
			{ TokenType::TOKEN_LITERAL_INTEGER,            "literal_integer"sv            },
			{ TokenType::TOKEN_LITERAL_STRING,             "literal_string"sv             },
			{ TokenType::TOKEN_SYMBOL_AMPERSAND,           "symbol_ampersand"sv           },
			{ TokenType::TOKEN_SYMBOL_AMPERSAND_AMPERSAND, "symbol_ampersand_ampersand"sv },
			{ TokenType::TOKEN_SYMBOL_CARET,               "symbol_caret"sv               },
			{ TokenType::TOKEN_SYMBOL_COMMA,               "symbol_comma"sv               },
			{ TokenType::TOKEN_SYMBOL_DOT,                 "symbol_dot"sv                 },
			{ TokenType::TOKEN_SYMBOL_GREATER,             "symbol_greater"sv             },
			{ TokenType::TOKEN_SYMBOL_GREATER_EQUAL,       "symbol_greater_equal"sv       },
			{ TokenType::TOKEN_SYMBOL_LESS,                "symbol_less"sv                },
			{ TokenType::TOKEN_SYMBOL_LESS_EQUAL,          "symbol_less_equal"sv          },
			{ TokenType::TOKEN_SYMBOL_MINUS,               "symbol_minus"sv               },
			{ TokenType::TOKEN_SYMBOL_MINUS_EQUAL,         "symbol_minus_equal"sv         },
			{ TokenType::TOKEN_SYMBOL_MINUS_MINUS,         "symbol_minus_minus"sv         },
			{ TokenType::TOKEN_SYMBOL_PERCENT,             "symbol_percent"sv             },
			{ TokenType::TOKEN_SYMBOL_PERCENT,             "symbol_percent_equal"sv       },
			{ TokenType::TOKEN_SYMBOL_PIPE,                "symbol_pipe"sv                },
			{ TokenType::TOKEN_SYMBOL_PIPE_PIPE,           "symbol_pipe_pipe"sv           },
			{ TokenType::TOKEN_SYMBOL_PLUS,                "symbol_plus"sv                },
			{ TokenType::TOKEN_SYMBOL_PLUS_EQUAL,          "symbol_plus_equal"sv          },
			{ TokenType::TOKEN_SYMBOL_PLUS_PLUS,           "symbol_plus_plus"sv           },
			{ TokenType::TOKEN_SYMBOL_QUESTION_MARK,       "symbol_question_mark"sv       },
			{ TokenType::TOKEN_SYMBOL_SLASH,               "symbol_slash"sv               },
			{ TokenType::TOKEN_SYMBOL_SLASH_EQUAL,         "symbol_slash_equal"sv         },
			{ TokenType::TOKEN_SYMBOL_STAR,                "symbol_star"sv                },
			{ TokenType::TOKEN_SYMBOL_STAR_EQUAL,          "symbol_star_equal"sv          },
			{ TokenType::TOKEN_SYMBOL_BANG,                "symbol_bang"sv                },
			{ TokenType::TOKEN_SYMBOL_BANG_EQUAL,          "symbol_bang_equal"sv          },
			{ TokenType::TOKEN_SYMBOL_BRACE_LEFT,          "symbol_brace_left"sv          },
			{ TokenType::TOKEN_SYMBOL_BRACE_RIGHT,         "symbol_brace_right"sv         },
			{ TokenType::TOKEN_SYMBOL_BRACKET_LEFT,        "symbol_bracket_left"sv        },
			{ TokenType::TOKEN_SYMBOL_BRACKET_RIGHT,       "symbol_bracket_right"sv       },
			{ TokenType::TOKEN_SYMBOL_COLON,               "symbol_colon"sv               },
			{ TokenType::TOKEN_SYMBOL_COLON_COLON,         "symbol_colon_colon"sv         },
			{ TokenType::TOKEN_SYMBOL_EQUAL,               "symbol_equal"sv               },
			{ TokenType::TOKEN_SYMBOL_EQUAL_EQUAL,         "symbol_equal_equal"sv         },
			{ TokenType::TOKEN_SYMBOL_PAREN_LEFT,          "symbol_paren_left"sv          },
			{ TokenType::TOKEN_SYMBOL_PAREN_RIGHT,         "symbol_paren_right"sv         },
			{ TokenType::TOKEN_SYMBOL_SEMICOLON,           "symbol_semicolon"sv           },
			{ TokenType::TOKEN_SPECIAL_ERROR,              "special_error"sv              },
			{ TokenType::TOKEN_SPECIAL_END_OF_FILE,        "special_eof"sv                },
		};
		return k_token_name.at(type);
	}
}  // namespace Soul
